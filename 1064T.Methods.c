#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    Gyro1,          sensorGyro)
#pragma config(Sensor, in2,    Gyro2,          sensorGyro)
#pragma config(Sensor, in3,    power,          sensorAnalog)
#pragma config(Sensor, in4,    rightPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in5,    leftPotentiometer, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  ledTank,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  ledArcade,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  lcdSwitch,      sensorTouch)
#pragma config(Sensor, dgtl4,  rightDrive,     sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  leftDrive,      sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  rightLift,      sensorNone)
#pragma config(Sensor, I2C_2,  leftLift,       sensorNone)
#pragma config(Motor,  port1,           ClawLeft,      tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftMid,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port3,           leftY,         tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port4,           rightBottom,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightTop,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftBottom,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftTop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightY,        tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port9,           rightMid,      tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port10,          ClawRight,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

//----///////////////////////////////GLOBALS/////////////////////////////////////////////////----

//--------------------LCD variables-------------------------------
//Declare count variable to keep track of our choice
int driveCount = 0; //drivemodecount
int autonSelec = 0; //auton mode
int autonComp  = 0; //auton
//lcd buttons
const short leftButton   = 1;
const short centerButton = 2;
const short rightButton  = 4;

//distance globals

int wheelDiameter = 4;
int driveTicks   = 360;
float turnTicks  = 6.56;

//----///////////////////////////////DRIVER METHODS///////////////////////////////////////////----

void time(int Msecs){//This method pauses code for a specified time
	wait1Msec(Msecs);
}

void lift(int power){//User/Control method controls the robots lift (positive power raises the lift
	motor[rightBottom] =  power;
	motor[rightTop]    =  power;
	motor[leftBottom]  = -power;
	motor[leftTop]     = -power;
}

void claw(int power) {
	motor[ClawLeft]  =  power;
	motor[ClawRight] = -power;
}
void drive(int left, int right){//Tank drive auton control method
	motor[leftY]     =  left;
	motor[leftMid]   =  left;
	motor[rightY]    =  right;
	motor[rightMid]  =  right;
}

void stopDrive(int timeLength){
	motor[rightY]   = 0;
	motor[leftY]    = 0;
	motor[rightMid] = 0;
	motor[leftMid]  = 0;
	time(timeLength);
}

void driveDist(int speedl, int speedr, int dist){
	SensorValue(leftDrive) = 0;
	int ticks = dist / (wheelDiameter*PI)* driveTicks*1.5;
	while (abs(SensorValue[leftDrive])&& (abs(SensorValue[rightDrive]) < ticks)){
		drive(speedl , speedr);
	}
	stopDrive(10);
	SensorValue(leftDrive)  = 0;
	SensorValue(rightDrive) = 0;
}

void driveAuton(int lpower, int rpower){
	motor[leftY]     =  lpower;
	motor[leftMid]   =  lpower;
	motor[rightY]    =  rpower;
	motor[rightMid]  =  rpower;
}

void liftAuton(int power){
	motor[rightBottom] =  power;
	motor[rightTop]    =  power;
	motor[leftBottom]  = -power;
	motor[leftTop]     = -power;
}

void clawAuton(int power){
	motor[ClawLeft]  =  power;
	motor[ClawRight] = -power;
}

//----///////////////////////////////Auton Selectio////////////////////////////////////////----

void auton1(){
	driveAuton(127, 100); liftAuton(127); clawAuton(127); time(500);

	driveAuton(120, 127); liftAuton(127); clawAuton(0); time(700);

	driveAuton(120, 127); liftAuton(0); clawAuton(0); time(600);

	driveAuton(120, 127); liftAuton(0);   clawAuton(0); time(200);

	driveAuton(0, 0); liftAuton(0); clawAuton(0); time(10000);




}

void auton3(){
	time(1);
}

void auton4(){
	time(1);
}

//----///////////////////////////////SENSOR METHODS//////////////////////////////////////////----

void resetGyro(){ //resets the Gryos during the robots start up
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[in1] = sensorNone;
	SensorType[in2] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in1] = sensorGyro;
	SensorType[in2] = sensorGyro;
	wait1Msec(2000);

}

void avgGyroValue(){
	displayLCDCenteredString(0,"Gyro Value");
	displayLCDNumber(1,5,(SensorValue[Gyro1] + SensorValue[Gyro2])/2,5);
}

void gyroTurn(int degrees2){
	//Adjust SensorScale to correct the scaling for your gyro
	//SensorScale[in8] = 260;
	//Adjust SensorFullCount to set the "rollover" point. A value of 3600 sets the rollover point to +/-3600
	//SensorFullCount[in8] = 3600;

	//Specify the number of degrees for the robot to turn (1 degree = 10, or 900 = 90 degrees)
	int degrees10 = degrees2;
	//Specify the amount of acceptable error in the turn
	int error = 5;

	//While the absolute value of the gyro is less than the desired rotation - 100...
	while((SensorValue[Gyro1] + SensorValue[Gyro2])/2 < degrees10 - 100)
	{
		motor[rightY]   = -127;
		motor[leftY]    =  127;
		motor[rightMid] = -127;
		motor[leftMid]  =  127;
	}
	//Brief brake to eliminate some drift
	motor[rightY]    =  5;
	motor[leftY]     = -5;
	motor[rightMid]  =  5;
	motor[leftMid]   = -5;
	wait1Msec(100);

	//Second while loop to move the robot more slowly to its goal, also setting up a range
	//for the amount of acceptable error in the system
	while((SensorValue[Gyro1] + SensorValue[Gyro2])/2 > degrees10 + error || (SensorValue[Gyro1] + SensorValue[Gyro2])/2 < degrees10 - error)
	{
		if((SensorValue[Gyro1] + SensorValue[Gyro2])/2 > degrees10)
		{
			motor[rightY]   = -80;
			motor[leftY]    =  80;
			motor[rightMid] = -80;
			motor[leftMid]  =  80;
		}
		else
		{
			motor[rightY]   =  80;
			motor[leftY]    = -80;
			motor[rightMid] =  80;
			motor[leftMid]  = -80;
		}
	}
	//Stop
	motor[rightY]   = 0;
	motor[leftY]    = 0;
	motor[rightMid] = 0;
	motor[leftMid]  = 0;
	wait1Msec(250);
}

void displayBatteryValues(){
	string mainBatteryVoltage, expanderBattery;
	displayLCDString(0,0,"Main batt: ");
	displayLCDString(1,0,"Secondary: ");
	sprintf(mainBatteryVoltage,"%1.2f%c",nImmediateBatteryLevel/1000.0,'V');
	sprintf(expanderBattery,"%1.2f%c",SensorValue[power]/280.0, 'V');
	displayLCDString(0,10,mainBatteryVoltage);
	displayLCDString(1,10,expanderBattery);
}

void resetLcd(){
	bLCDBacklight = true;
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
}

void waitForPress(){//Pauses the lcd display until a button is pressed
	while(nLCDButtons == 0){}
	wait1Msec(5);
}

void waitForRelease(){//Pauses the lcd display until a button is released
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

void selectAuton(){
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton){
		switch(autonSelec){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "1. Fence Blue");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				autonSelec = 4;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				autonSelec++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "2.  Fence Red");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				autonSelec--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				autonSelec++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "3. Clear All Blu");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				autonSelec--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				autonSelec++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "4. Clear All Red");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				autonSelec++;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				autonSelec = 4;
			}

			break;
		case 4:
			displayBatteryValues();
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				autonSelec--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				autonSelec = 0;
			}
		default:
			autonSelec = 0;
			break;
		}
		time(10);
	}
}

void nothing(){
	displayLCDCenteredString(0, "slot");
	displayLCDCenteredString(1, "here");
}
void lcdAuton(){ //autonomous selection on lcd
	resetLcd();
	//Switch Case that actually runs the user choice
	switch(autonSelec){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "1. Auton 1");
		displayLCDCenteredString(1, "   is running!  ");
		// First auton option
		auton1();
		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Auton 2");
		displayLCDCenteredString(1, "is running!");
		//second auton option
		lift(127);time(1);
		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Auton 3");
		displayLCDCenteredString(1, "is running!");
		//third auton option
		auton3();
		break;
	case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "Auton 4");
		displayLCDCenteredString(1, "is running!");
		//fourth auton option
		auton4();
		break;
	}
}
