#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Gyro1,          sensorGyro)
#pragma config(Sensor, in2,    Gyro2,          sensorGyro)
#pragma config(Sensor, in3,    power,          sensorAnalog)
#pragma config(Sensor, dgtl1,  ledTank,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  ledArcade,      sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftFront,     tmotorVex393_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           rightFront,    tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port3,           leftBack,      tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_4)
#pragma config(Motor,  port4,           rightBack,     tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_3)
#pragma config(Motor,  port5,           YRightLift,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RightLift,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           YLeftLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LeftLift,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           ClawLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          ClawRight,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

//----///////////////////////////////GLOBALS/////////////////////////////////////////////////----
//(SensorValue[Gyro1] + SensorValue[Gyro2])/2
//--------------------LCD variables-------------------------------
//Declare count variable to keep track of our choice
int driveCount = 0; //drivemodecount
int autonSelec = 0; //auton mode
int autonComp  = 0; //auton
//lcd buttons
const short leftButton   = 1;
const short centerButton = 2;
const short rightButton  = 4;

//----///////////////////////////////DRIVER METHODS///////////////////////////////////////////----

void lift(int power){//User/Control method controls the robots lift (positive power raises the lift
	motor[YRightLift] = -power;
	motor[RightLift]  = -power;
	motor[YLeftLift]  =  power;
	motor[LeftLift]   =  power;
}

void clawRight(int power){
	motor[ClawLeft] = power;
}

void clawLeft(int power){
	motor[ClawRight] = power;
}

void claw(int power) {
	motor[ClawLeft]  = -power;
	motor[ClawRight] =  power;
}
void drive(int left, int right){//Tank drive auton control method
	motor[leftFront]  =  left;
	motor[leftBack]   =  left;
	motor[rightFront] =  right;
	motor[rightBack]  =  right;
}

void time(int Msecs){//This method pauses code for a specified time
	wait1Msec(Msecs);
}

//----///////////////////////////////Auton Selections////////////////////////////////////////----

void auton1(){
	lift(127); claw(127);                  time(175);
	lift(127); drive(127, 127); claw(0);   time(2000);
	lift(0); drive(0, 0); claw(0);         time(100000);
}

void autonLift(int power,int time){
	lift(power); wait1Msec(time);
}

void auton3(){
	time(1);
}

void auton4(){
	time(1);
}

//----///////////////////////////////SENSOR METHODS//////////////////////////////////////////----

void resetGyro(){ //resets the Gryos during the robots start up
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[in1] = sensorNone;
	SensorType[in2] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in1] = sensorGyro;
	SensorType[in2] = sensorGyro;
	wait1Msec(2000);

}

void avgGyroValue(){
	displayLCDCenteredString(0,"Gyro Value");
	displayLCDNumber(1,5,(SensorValue[Gyro1] + SensorValue[Gyro2])/2,5);
}

void gyroTurn(int degrees2){
	//Adjust SensorScale to correct the scaling for your gyro
	//SensorScale[in8] = 260;
	//Adjust SensorFullCount to set the "rollover" point. A value of 3600 sets the rollover point to +/-3600
	//SensorFullCount[in8] = 3600;

	//Specify the number of degrees for the robot to turn (1 degree = 10, or 900 = 90 degrees)
	int degrees10 = degrees2;
	//Specify the amount of acceptable error in the turn
	int error = 5;

	//While the absolute value of the gyro is less than the desired rotation - 100...
	while((SensorValue[Gyro1] + SensorValue[Gyro2])/2 < degrees10 - 100)
	{
		motor[rightFront] =  127;
		motor[leftFront]  = -127;
		motor[rightBack]  =  127;
		motor[leftBack]   = -127;
	}
	//Brief brake to eliminate some drift
	motor[rightFront] = -5;
	motor[leftFront]  =  5;
	motor[rightBack]  = -5;
	motor[leftBack]   =  5;
	wait1Msec(100);

	//Second while loop to move the robot more slowly to its goal, also setting up a range
	//for the amount of acceptable error in the system
	while((SensorValue[Gyro1] + SensorValue[Gyro2])/2 > degrees10 + error || (SensorValue[Gyro1] + SensorValue[Gyro2])/2 < degrees10 - error)
	{
		if((SensorValue[Gyro1] + SensorValue[Gyro2])/2 > degrees10)
		{
			motor[rightFront] = -100;
			motor[leftFront]  =  100;
			motor[rightBack]  = -100;
			motor[leftBack]   =  100;
		}
		else
		{
			motor[rightFront] =  100;
			motor[leftFront]  = -100;
			motor[rightBack]  =  100;
			motor[leftBack]   = -100;
		}
	}
	//Stop
	motor[rightFront] = 0;
	motor[leftFront]  = 0;
	motor[rightBack]  = 0;
	motor[leftBack]   = 0;
	wait1Msec(250);
}

void displayBatteryValues(){
	string mainBatteryVoltage, expanderBattery;
	displayLCDString(0,0,"Main batt: ");
	displayLCDString(1,0,"Secondary: ");
	sprintf(mainBatteryVoltage,"%1.2f%c",nImmediateBatteryLevel/1000.0,'V');
	sprintf(expanderBattery,"%1.2f%c",SensorValue[power]/280.0, 'V');
	displayLCDString(0,10,mainBatteryVoltage);
	displayLCDString(1,10,expanderBattery);
}

void resetLcd(){
	bLCDBacklight = true;
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
}

void waitForPress(){//Pauses the lcd display until a button is pressed
	while(nLCDButtons == 0){}
	wait1Msec(5);
}

void waitForRelease(){//Pauses the lcd display until a button is released
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

void selectAuton(){
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton){
		switch(autonSelec){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "1. Fence");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				autonSelec = 3;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				autonSelec++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "2.  Auton 2");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				autonSelec--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				autonSelec++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "3. Auton 3");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				autonSelec--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				autonSelec++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "4. Driver");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				autonSelec--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				autonSelec = 4;
			}

			break;
		case 4:
			displayBatteryValues();
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				autonSelec--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				autonSelec = 0;
			}
		default:
			autonSelec = 0;
			break;
		}
		time(10);
	}
}

void nothing(){
	displayLCDCenteredString(0, "nothing");
	displayLCDCenteredString(1, "here");
	time(10);
}
void lcdAuton(){ //autonomous selection on lcd
	resetLcd();
	//Switch Case that actually runs the user choice
	switch(autonSelec){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "1. Auton 1");
		displayLCDCenteredString(1, "   is running!  ");
		// First auton option
		auton1();
		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Auton 2");
		displayLCDCenteredString(1, "is running!");
		//second auton option
		autonLift(127,1);
		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Auton 3");
		displayLCDCenteredString(1, "is running!");
		//third auton option
		auton3();
		break;
	case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "Auton 4");
		displayLCDCenteredString(1, "is running!");
		//fourth auton option
		auton4();
		break;
	}
}
