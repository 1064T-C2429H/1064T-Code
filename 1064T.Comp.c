#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Sensor, in2,    Gyro2,          sensorGyro)
#pragma config(Sensor, in3,    xAccel,         sensorAccelerometer)
#pragma config(Sensor, in4,    yAccel,         sensorAccelerometer)
#pragma config(Sensor, in5,    zAccel,         sensorAccelerometer)
#pragma config(Sensor, dgtl1,  ledTank,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  ledArcade,      sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftFront,     tmotorVex393_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           rightFront,    tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port3,           leftBack,      tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_4)
#pragma config(Motor,  port4,           rightBack,     tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_3)
#pragma config(Motor,  port5,           YRightLift,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RightLift,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           YLeftLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LeftLift,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           ClawLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          ClawRight,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

//init global varibals
int GLOBAL_display= 1;

const int GLOBAL_DOUBLE_CLICK_SPEED = 250;
const short lcdRightButton = 1;
const short lcdCenterButton = 2;
const short lcdLeftButton = 4;

//-----------------------------LCD METHODS------------------------
//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------
//--------------------LCD variables-------------------------------
//Declare count variable to keep track of our choice
int count = 0;
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;


//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

// driver methods-------------------------------------------------
// drive Tank code method
void driveTank(int joyLeft, int joyRight){
	motor[leftFront] = vexRT[Ch3];
	motor[rightFront] = vexRT[Ch2];
	motor[leftBack] = vexRT[Ch3];
	motor[rightBack] = vexRT[Ch2];
}

//auton method for Drive on the Y axis
void driveY(int power){
	motor[leftFront]  =  power;
	motor[rightFront] =  power;
	motor[leftBack]   =  power;
	motor[rightBack]  =  power;
}

//auton method to turn drive based on Gyro avg
void gyroTurn(int degrees2){
		//gyro config
		//Completely clear out any previous sensor readings by setting the port to "sensorNone"
		SensorType[Gyro] = sensorNone;
		SensorType[Gyro2] = sensorNone;
		wait1Msec(500);
		//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
		SensorType[Gyro] = sensorGyro;
		SensorType[Gyro2] = sensorGyro;
		wait1Msec(1500);

		//Adjust SensorScale to correct the scaling for your gyro
		//SensorScale[in8] = 260;
		//Adjust SensorFullCount to set the "rollover" point. A value of 3600 sets the rollover point to +/-3600
		//SensorFullCount[in8] = 3600;

		//Specify the number of degrees for the robot to turn (1 degree = 10, or 900 = 90 degrees)
		int degrees10 = degrees2;
		//Specify the amount of acceptable error in the turn
		int error = 5;

		//While the absolute value of the gyro is less than the desired rotation - 100...
		while(SensorValue[Gyro] < degrees10 - 100)
		{
			motor[rightFront] = 127;
			motor[leftFront] = -127;
			motor[rightBack] = 127;
			motor[leftBack] = -127;
		}
		//Brief brake to eliminate some drift
		motor[rightFront] = -5;
		motor[leftFront] = 5;
		motor[rightBack] = -5;
		motor[leftBack] = 5;
		wait1Msec(100);

		//Second while loop to move the robot more slowly to its goal, also setting up a range
		//for the amount of acceptable error in the system
		while(SensorValue[Gyro] > degrees10 + error || SensorValue[Gyro] < degrees10 - error)
		{
			if(SensorValue[Gyro] > degrees10)
			{
				motor[rightFront] = -100;
				motor[leftFront] = 100;
				motor[rightBack] = -100;
				motor[leftBack] = 100;
			}
			else
			{
				motor[rightFront] = 100;
				motor[leftFront] = -100;
				motor[rightBack] = 100;
				motor[leftBack] = -100;
			}
		}
		//Stop
		motor[rightFront] = 0;
		motor[leftFront] = 0;
		motor[rightBack] = 0;
		motor[leftBack] = 0;
		wait1Msec(250);

}
//lift method raise
void lift(int power){
	motor[YRightLift] = -power;
	motor[RightLift] = -power;
	motor[YLeftLift] = power;
	motor[LeftLift] =  power;
}

//claw method
void claw(int power){
	motor[ClawLeft] = -power;
	motor[ClawRight] = power;
}
//end driver methods--------------------------------------------

void pre_auton(){
	//-------------LCD auton selec----------------------------------
	//------------- Beginning of User Interface Code ---------------
	bLCDBacklight = true;
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Knock down stars");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 3;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "2.  Raise Lift  ");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "Gyro turn");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "Driver");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = 0;
			break;
		}
	}
	//------------- End of User Interface Code ---------------------


	//gyro config
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[Gyro] = sensorNone;
	SensorType[Gyro2] = sensorNone;
	wait1Msec(500);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[Gyro] = sensorGyro;
	SensorType[Gyro2] = sensorGyro;
	wait1Msec(1500);

}

task autonomous(){
	//------------- Beginning of Robot Movement Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Knock down stars");
		displayLCDCenteredString(1, "   is running!  ");
		driveY(127); 		wait1Msec(2000); //Bot drives up to fence
		driveY(0); 		  wait1Msec(1);    //stop bot
		lift(127);      wait1Msec(1000); //Raise lift to fence
		lift(0);				wait1Msec(1);		 //Stop bot
		driveY(-127);		wait1Msec(500);  //Drive back to mid feild
		driveY(0); 			wait1Msec(10000);

		// First auton option
		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Raise Lift ");
		displayLCDCenteredString(1, "is running!");
		lift(127);
		wait1Msec(1000);						// Robot waits for 2000 milliseconds
		lift(0);
		wait1Msec(10000);
		//second auton option
		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Gyro Turn");
		displayLCDCenteredString(1, "is running!");
		gyroTurn(-900);


		//third auton option
		break;
	case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "Auton option 4");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2);						// Robot waits for 2000 milliseconds

		//fourth auton option
		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
	}
	//------------- End of Robot Movement Code -----------------------

}
//---------------END of auton---------------------------------------

task usercontrol(){

	bool useTank = true;

	if(!useTank){ //LED driver type indicater
		turnLEDOn(dgtl2);
		turnLEDOff(dgtl1);
		}else{
		turnLEDOn(dgtl1);
		turnLEDOff(dgtl2);
	}

	while(true){

		if(vexRT[Btn7U]){
			if(useTank){
				useTank = false;
				turnLEDOn(dgtl2);
				turnLEDOff(dgtl1);
				}else{
				useTank = true;
				turnLEDOn(dgtl1);
				turnLEDOff(dgtl2);
			}
			wait1Msec(200);
		}

		if(vexRT[Btn6U]){ // Lift up
			lift(127);
			}else if(vexRT[Btn5U]){// Lift down
			lift(-127);
			}else{
			lift(0);
		}

		if(vexRT[Btn6D]){ // Open claw
			claw(127);
			}else if(vexRT[Btn5D]){ // Close claw
			claw(-127);
			}else{
			claw(0);
		}

		if(useTank){
			int joyRight = vexRT[Ch2];
			int joyLeft = vexRT[Ch3];
			driveTank(joyLeft, joyRight);
			}else{
			int joy_x = vexRT[Ch1];
			int joy_y = vexRT[Ch2];

			motor[leftFront] = joy_y + joy_x;
			motor[leftBack] = joy_y + joy_x;
			motor[rightFront] = joy_y - joy_x;
			motor[rightBack] = joy_y - joy_x;
		}
	}
}
