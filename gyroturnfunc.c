#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Sensor, in2,    Gyro2,          sensorGyro)
#pragma config(Sensor, in3,    xAccel,         sensorAccelerometer)
#pragma config(Sensor, in4,    yAccel,         sensorAccelerometer)
#pragma config(Sensor, in5,    zAccel,         sensorAccelerometer)
#pragma config(Sensor, dgtl1,  ledTank,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  ledArcade,      sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftFront,     tmotorVex393_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           rightFront,    tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port3,           leftBack,      tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_4)
#pragma config(Motor,  port4,           rightBack,     tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_3)
#pragma config(Motor,  port5,           YRightLift,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RightLift,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           YLeftLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LeftLift,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           ClawLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          ClawRight,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Gyro Based Turns - Better
-This program instructs your robot to turn for the specified number of degrees in "degrees10".
-The first while loop moves the robot most of the way toward the specified number of degrees, exiting
10 degrees (100 sensor counts) short of the goal.
-This program includes a second while loop which incorporates a specified error value to determine
an acceptable range and allow the robot to turn more slowly toward its goal, eliminating much of
the drift in the system.
-For best sensor results, clear out the gyro and manually configure it at the begging of the code.
-The Gyro is configured by default to provide values from 0 to -3600 for clockwise rotation,
and 0 to 3600 for counter-clockwise rotation

Robot Model(s): Swervebot

[I/O Port]          [Name]              [Type]                [Description]
Motor Port 2        rightMotor          VEX Motor             Right side motor
Motor Port 3        leftMotor           VEX Motor             Left side motor
Analog Port 8       in8                 VEX Gyro              Top-center mounted,
away from the Cortex
----------------------------------------------------------------------------------------------------*/
	void gyroTurn(int degrees2){
		clearLCDLine(0);
		clearLCDLine(1);
		bLCDBacklight = true;
		displayLCDCenteredString(0, "Gyro Test");

		//gyro config
		//Completely clear out any previous sensor readings by setting the port to "sensorNone"
		SensorType[Gyro] = sensorNone;
		SensorType[Gyro2] = sensorNone;
		wait1Msec(500);
		//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
		SensorType[Gyro] = sensorGyro;
		SensorType[Gyro2] = sensorGyro;
		wait1Msec(1500);

		//Adjust SensorScale to correct the scaling for your gyro
		//SensorScale[in8] = 260;
		//Adjust SensorFullCount to set the "rollover" point. A value of 3600 sets the rollover point to +/-3600
		//SensorFullCount[in8] = 3600;

		//Specify the number of degrees for the robot to turn (1 degree = 10, or 900 = 90 degrees)
		int degrees10 = degrees2;
		//Specify the amount of acceptable error in the turn
		int error = 5;

		//While the absolute value of the gyro is less than the desired rotation - 100...
		while(SensorValue[Gyro] < degrees10 - 100)
		{
			motor[rightFront] = 127;
			motor[leftFront] = -127;
			motor[rightBack] = 127;
			motor[leftBack] = -127;
		}
		//Brief brake to eliminate some drift
		motor[rightFront] = -5;
		motor[leftFront] = 5;
		motor[rightBack] = -5;
		motor[leftBack] = 5;
		wait1Msec(100);

		//Second while loop to move the robot more slowly to its goal, also setting up a range
		//for the amount of acceptable error in the system
		while(SensorValue[Gyro] > degrees10 + error || SensorValue[Gyro] < degrees10 - error)
		{
			if(SensorValue[Gyro] > degrees10)
			{
				motor[rightFront] = -100;
				motor[leftFront] = 100;
				motor[rightBack] = -100;
				motor[leftBack] = 100;
			}
			else
			{
				motor[rightFront] = 100;
				motor[leftFront] = -100;
				motor[rightBack] = 100;
				motor[leftBack] = -100;
			}
		}
		//Stop
		motor[rightFront] = 0;
		motor[leftFront] = 0;
		motor[rightBack] = 0;
		motor[leftBack] = 0;
		wait1Msec(250);
	}

task main()
{
	gyroTurn(900);
}
